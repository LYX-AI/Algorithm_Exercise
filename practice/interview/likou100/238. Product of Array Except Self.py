'''
这道题的整体思路：
非常好！你这个问题问得很到位👏——\*\*“为什么前缀积 × 后缀积就能得到我们要的结果？”\*\*我们就来深入理解这个原理，**不是死记，而是真正看懂它背后的数学逻辑。**

---

## 🌟我们的目标是：

对于每个下标 `i`，我们要计算：

```text
answer[i] = 除了 nums[i] 以外所有 nums 中元素的乘积
```

也就是：

```text
answer[i] = nums[0] * nums[1] * ... * nums[i-1] * nums[i+1] * ... * nums[n-1]
```

---

## ✨引入两个关键概念：

我们用两个变量来辅助这个计算：

* `prefix[i]` 表示：`nums[0] * nums[1] * ... * nums[i-1]`（即 **i 左边所有数的乘积**）
* `suffix[i]` 表示：`nums[i+1] * nums[i+2] * ... * nums[n-1]`（即 **i 右边所有数的乘积**）

那么：

```text
answer[i] = prefix[i] * suffix[i]
```

是不是就完美解决了？✅ 因为这两个部分加起来就是“除了 `nums[i]` 本身以外的乘积”。

---

## 🔍举个具体例子来验证这个逻辑：

假设：

```python
nums = [1, 2, 3, 4]
```

我们想求：

```python
answer[0] = 2 * 3 * 4 = 24
answer[1] = 1 * 3 * 4 = 12
answer[2] = 1 * 2 * 4 = 8
answer[3] = 1 * 2 * 3 = 6
```

---

我们来手动计算一遍：

### 第一步：前缀积（从左往右）

```python
prefix = [1, 1, 2, 6]
解释：
prefix[0] = 没有左边 => 1
prefix[1] = 1
prefix[2] = 1 * 2 = 2
prefix[3] = 1 * 2 * 3 = 6
```

### 第二步：后缀积（从右往左）

```python
suffix = [24, 12, 4, 1]
解释：
suffix[3] = 没有右边 => 1
suffix[2] = 4
suffix[1] = 3 * 4 = 12
suffix[0] = 2 * 3 * 4 = 24
```

### 第三步：前缀 × 后缀

```python
answer[i] = prefix[i] * suffix[i]
answer = [1*24, 1*12, 2*4, 6*1] = [24, 12, 8, 6]
```

完美！✅

---

## ✅ 为什么不能用前缀积或后缀积单独计算？

因为**我们要跳过当前元素本身**，所以必须把当前元素左边和右边的部分分开计算——**“拼起来但不包含自己”**，只有前缀积 × 后缀积可以做到这一点。

---

## 💡通俗比喻：

假设你是一个人站在一排人中：

* 你左边的人全都手拉手做了一个链条（前缀积）
* 你右边的人也拉成一个链条（后缀积）
* 你不参与任何链条，但你要知道：左右两条链条合起来的力量是多少（前缀 × 后缀）

---

## 总结一句话：

> **每个元素要跳过自己，只能靠“左右两边乘积”合并，前缀乘积负责左边，后缀乘积负责右边，拼起来就是答案。**

---

如果你觉得我解释得还不够形象，或者想我写个图形化的版本辅助记忆，也可以告诉我！我们可以做个“纸面推导图”来视觉化理解。是否继续？


'''
class Solution:
    def productExceptSelf(self, nums: list[int]) -> list[int]:
      n = len(nums)
      result = [1]*n

      #计算前缀
      prfix = 1
      for i in range(n):
          result[i] = prfix
          prfix *= nums[i]

      #计算后缀
      suffix = 1
      for i in range(n-1,-1,-1):
          result[i] *= suffix
          suffix *= nums[i]

      return result


